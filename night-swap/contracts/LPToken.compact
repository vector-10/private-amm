// SPDX-License-Identifier: MIT
// contracts/lp-token/LPToken.compact

pragma language_version >= 0.18.0;

module LPToken {
  import CompactStandardLibrary;

  // Public state
  export ledger _totalSupply: Uint<128>;
  export ledger _poolAddress: Either<ZswapCoinPublicKey, ContractAddress>;

  // Private state
  ledger _balances: Table<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>;

  /**
   * @description Initializes the LP token with the pool address
   */
  export circuit initialize(
    poolAddress: Either<ZswapCoinPublicKey, ContractAddress>
  ): [] {
    _poolAddress = poolAddress;
    _totalSupply = 0u128;
  }

  /**
   * @description Returns the total supply
   */
  export circuit totalSupply(): Uint<128> {
    return _totalSupply;
  }

  /**
   * @description Returns the balance of an account
   */
  export circuit balanceOf(account: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
    const balance = _balances[account];
    if (balance.is_some) {
      return balance.value;
    }
    return 0u128;
  }

  /**
   * @description Transfer LP tokens
   */
  export circuit transfer(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    @witness amount: Uint<128>
  ): [] {
    const senderBalance = _balances[from];
    assert(senderBalance.is_some, "No balance");
    assert(senderBalance.value >= amount, "Insufficient LP token balance");

    _balances[from] = senderBalance.value - amount;

    const recipientBalance = _balances[to];
    if (recipientBalance.is_some) {
      _balances[to] = recipientBalance.value + amount;
    } else {
      _balances[to] = amount;
    }
  }

  /**
   * @description Mint LP tokens (only callable by pool)
   */
  export circuit mint(
    caller: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    @witness amount: Uint<128>
  ): [] {
    assert(caller == _poolAddress, "Only pool can mint");

    _totalSupply = _totalSupply + amount;

    const recipientBalance = _balances[to];
    if (recipientBalance.is_some) {
      _balances[to] = recipientBalance.value + amount;
    } else {
      _balances[to] = amount;
    }
  }

  /**
   * @description Burn LP tokens (only callable by pool)
   */
  export circuit burn(
    caller: Either<ZswapCoinPublicKey, ContractAddress>,
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    @witness amount: Uint<128>
  ): [] {
    assert(caller == _poolAddress, "Only pool can burn");

    const holderBalance = _balances[from];
    assert(holderBalance.is_some, "No balance");
    assert(holderBalance.value >= amount, "Insufficient LP tokens to burn");

    _balances[from] = holderBalance.value - amount;
    _totalSupply = _totalSupply - amount;
  }
}