// SPDX-License-Identifier: MIT
// contracts/amm/AMM.compact

pragma language_version >= 0.18.0;

module AMM {
  import CompactStandardLibrary;

  // Public state - reserves must be public for price discovery
  export ledger _tokenA: Either<ZswapCoinPublicKey, ContractAddress>;
  export ledger _tokenB: Either<ZswapCoinPublicKey, ContractAddress>;
  export ledger _lpToken: Either<ZswapCoinPublicKey, ContractAddress>;
  export ledger _reserveA: Uint<128>;
  export ledger _reserveB: Uint<128>;
  export ledger _initialized: Boolean;

  // Constants
  const FEE_NUMERATOR: Uint<128> = 997u128;
  const FEE_DENOMINATOR: Uint<128> = 1000u128;
  const MINIMUM_LIQUIDITY: Uint<128> = 1000u128;

  /**
   * @description Initializes the AMM with token addresses
   */
  export circuit initialize(
    tokenA: Either<ZswapCoinPublicKey, ContractAddress>,
    tokenB: Either<ZswapCoinPublicKey, ContractAddress>,
    lpToken: Either<ZswapCoinPublicKey, ContractAddress>
  ): [] {
    _tokenA = tokenA;
    _tokenB = tokenB;
    _lpToken = lpToken;
    _reserveA = 0u128;
    _reserveB = 0u128;
    _initialized = false;
  }

  /**
   * @description Returns the constant product k = x * y
   */
  export circuit getK(): Uint<128> {
    return _reserveA * _reserveB;
  }

  /**
   * @description Returns current reserves
   */
  export circuit getReserves(): (Uint<128>, Uint<128>) {
    return (_reserveA, _reserveB);
  }

  /**
   * @description Calculate output amount for a swap
   */
  export circuit getAmountOut(
    amountIn: Uint<128>,
    reserveIn: Uint<128>,
    reserveOut: Uint<128>
  ): Uint<128> {
    assert(amountIn > 0u128, "Insufficient input amount");
    assert(reserveIn > 0u128, "Insufficient liquidity");
    assert(reserveOut > 0u128, "Insufficient liquidity");

    const amountInWithFee = amountIn * FEE_NUMERATOR;
    const numerator = amountInWithFee * reserveOut;
    const denominator = (reserveIn * FEE_DENOMINATOR) + amountInWithFee;

    return numerator / denominator;
  }

  /**
   * @description Swap tokens - privacy-preserving
   * Trade amounts are private (@witness), only reserve updates are public
   */
  export circuit swap(
    caller: Either<ZswapCoinPublicKey, ContractAddress>,
    @witness amountIn: Uint<128>,
    @witness minAmountOut: Uint<128>,
    isAToB: Boolean
  ): Uint<128> {
    assert(amountIn > 0u128, "Insufficient input amount");

    const amountInWithFee = amountIn * FEE_NUMERATOR;
    let amountOut: Uint<128>;

    if (isAToB) {
      const numerator = amountInWithFee * _reserveB;
      const denominator = (_reserveA * FEE_DENOMINATOR) + amountInWithFee;
      amountOut = numerator / denominator;

      assert(amountOut >= minAmountOut, "Slippage too high");
      assert(amountOut < _reserveB, "Insufficient liquidity");

      _reserveA = _reserveA + amountIn;
      _reserveB = _reserveB - amountOut;
    } else {
      const numerator = amountInWithFee * _reserveA;
      const denominator = (_reserveB * FEE_DENOMINATOR) + amountInWithFee;
      amountOut = numerator / denominator;

      assert(amountOut >= minAmountOut, "Slippage too high");
      assert(amountOut < _reserveA, "Insufficient liquidity");

      _reserveB = _reserveB + amountIn;
      _reserveA = _reserveA - amountOut;
    }

    return amountOut;
  }

  /**
   * @description Add liquidity to the pool
   */
  export circuit addLiquidity(
    caller: Either<ZswapCoinPublicKey, ContractAddress>,
    @witness amountA: Uint<128>,
    @witness amountB: Uint<128>,
    @witness minLiquidity: Uint<128>
  ): Uint<128> {
    assert(amountA > 0u128, "Insufficient amount A");
    assert(amountB > 0u128, "Insufficient amount B");

    let liquidity: Uint<128>;

    if (!_initialized) {
      // First liquidity provision - sets initial price
      const product = amountA * amountB;
      liquidity = sqrt(product);
      assert(liquidity > MINIMUM_LIQUIDITY, "Insufficient initial liquidity");

      // Lock minimum liquidity forever
      liquidity = liquidity - MINIMUM_LIQUIDITY;
      _initialized = true;
    } else {
      // Subsequent liquidity - calculate based on current ratio
      // Get total supply from LP token (simplified here)
      const totalSupply = _reserveA + _reserveB; // Placeholder - should call lpToken.totalSupply()
      
      const liquidityA = (amountA * totalSupply) / _reserveA;
      const liquidityB = (amountB * totalSupply) / _reserveB;
      
      if (liquidityA < liquidityB) {
        liquidity = liquidityA;
      } else {
        liquidity = liquidityB;
      }
      
      assert(liquidity >= minLiquidity, "Insufficient liquidity minted");
    }

    _reserveA = _reserveA + amountA;
    _reserveB = _reserveB + amountB;

    return liquidity;
  }

  /**
   * @description Remove liquidity from the pool
   */
  export circuit removeLiquidity(
    caller: Either<ZswapCoinPublicKey, ContractAddress>,
    @witness lpAmount: Uint<128>,
    @witness minAmountA: Uint<128>,
    @witness minAmountB: Uint<128>
  ): (Uint<128>, Uint<128>) {
    assert(lpAmount > 0u128, "Insufficient liquidity burned");

    // Get total supply (simplified - should call lpToken.totalSupply())
    const totalSupply = _reserveA + _reserveB; // Placeholder

    const amountA = (lpAmount * _reserveA) / totalSupply;
    const amountB = (lpAmount * _reserveB) / totalSupply;

    assert(amountA >= minAmountA, "Insufficient A amount");
    assert(amountB >= minAmountB, "Insufficient B amount");

    _reserveA = _reserveA - amountA;
    _reserveB = _reserveB - amountB;

    return (amountA, amountB);
  }

  /**
   * @description Integer square root using Newton's method
   */
  pure circuit sqrt(x: Uint<128>): Uint<128> {
    if (x == 0u128) {
      return 0u128;
    }

    let z = x / 2u128 + 1u128;
    let y = x;
    let i = 0u8;

    while (i < 10u8) {
      if (z >= y) {
        return y;
      }
      y = z;
      z = (x / z + z) / 2u128;
      i = i + 1u8;
    }

    return y;
  }
}