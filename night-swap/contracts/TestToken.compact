// SPDX-License-Identifier: MIT
// contracts/test-token/TestToken.compact

pragma language_version >= 0.18.0;

module TestToken {
  import CompactStandardLibrary;

  // Public state
  export ledger _totalSupply: Uint<128>;
  export ledger _name: Opaque<"string">;
  export ledger _symbol: Opaque<"string">;

  // Private state
  ledger _balances: Table<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>;
  ledger _allowances: Table
    Either<ZswapCoinPublicKey, ContractAddress>,
    Table<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>
  >;

  /**
   * @description Initializes the token with name, symbol, and initial supply
   */
  export circuit initialize(
    name_: Opaque<"string">,
    symbol_: Opaque<"string">,
    initialSupply: Uint<128>,
    owner: Either<ZswapCoinPublicKey, ContractAddress>
  ): [] {
    _name = name_;
    _symbol = symbol_;
    _totalSupply = initialSupply;
    _balances[owner] = initialSupply;
  }

  /**
   * @description Returns the token name
   */
  export circuit name(): Opaque<"string"> {
    return _name;
  }

  /**
   * @description Returns the token symbol
   */
  export circuit symbol(): Opaque<"string"> {
    return _symbol;
  }

  /**
   * @description Returns the total supply
   */
  export circuit totalSupply(): Uint<128> {
    return _totalSupply;
  }

  /**
   * @description Returns the balance of an account
   */
  export circuit balanceOf(account: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
    const balance = _balances[account];
    if (balance.is_some) {
      return balance.value;
    }
    return 0u128;
  }

  /**
   * @description Returns the allowance
   */
  export circuit allowance(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>
  ): Uint<128> {
    const ownerAllowances = _allowances[owner];
    if (ownerAllowances.is_some) {
      const allowed = ownerAllowances.value[spender];
      if (allowed.is_some) {
        return allowed.value;
      }
    }
    return 0u128;
  }

  /**
   * @description Transfer tokens
   */
  export circuit transfer(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    @witness amount: Uint<128>
  ): [] {
    const senderBalance = _balances[from];
    assert(senderBalance.is_some, "No balance");
    assert(senderBalance.value >= amount, "Insufficient balance");

    _balances[from] = senderBalance.value - amount;

    const recipientBalance = _balances[to];
    if (recipientBalance.is_some) {
      _balances[to] = recipientBalance.value + amount;
    } else {
      _balances[to] = amount;
    }
  }

  /**
   * @description Approve spender
   */
  export circuit approve(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    @witness amount: Uint<128>
  ): [] {
    const ownerAllowances = _allowances[owner];
    if (ownerAllowances.is_some) {
      ownerAllowances.value[spender] = amount;
    } else {
      const newTable: Table<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>;
      newTable[spender] = amount;
      _allowances[owner] = newTable;
    }
  }

  /**
   * @description Transfer from (used by AMM)
   */
  export circuit transferFrom(
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    @witness amount: Uint<128>
  ): [] {
    const ownerAllowances = _allowances[from];
    assert(ownerAllowances.is_some, "No allowance");
    
    const currentAllowance = ownerAllowances.value[spender];
    assert(currentAllowance.is_some, "No allowance for spender");
    assert(currentAllowance.value >= amount, "Insufficient allowance");

    const senderBalance = _balances[from];
    assert(senderBalance.is_some, "No balance");
    assert(senderBalance.value >= amount, "Insufficient balance");

    ownerAllowances.value[spender] = currentAllowance.value - amount;
    _balances[from] = senderBalance.value - amount;

    const recipientBalance = _balances[to];
    if (recipientBalance.is_some) {
      _balances[to] = recipientBalance.value + amount;
    } else {
      _balances[to] = amount;
    }
  }

  /**
   * @description Mint new tokens
   */
  export circuit mint(
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    @witness amount: Uint<128>
  ): [] {
    _totalSupply = _totalSupply + amount;

    const recipientBalance = _balances[to];
    if (recipientBalance.is_some) {
      _balances[to] = recipientBalance.value + amount;
    } else {
      _balances[to] = amount;
    }
  }
}