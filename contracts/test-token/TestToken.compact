// contracts/test-token/TestToken.compact
pragma language_version >= 0.18.0;

import CompactStandardLibrary;

circuit TestToken {
    public state {
        total_supply: Uint<128>,
        name: Opaque<"string">,
        symbol: Opaque<"string">
    }

    state balances: Table<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>;
    state allowances: Table
        Either<ZswapCoinPublicKey, ContractAddress>,
        Table<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>
    >;

    constructor(
        _name: Opaque<"string">,
        _symbol: Opaque<"string">,
        _initial_supply: Uint<128>,
        _owner: Either<ZswapCoinPublicKey, ContractAddress>
    ) {
        name = _name;
        symbol = _symbol;
        total_supply = _initial_supply;
        balances[_owner] = _initial_supply;
    }

    query balance_of(account: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
        return balances[account] ?? 0u128;
    }

    query allowance(
        owner: Either<ZswapCoinPublicKey, ContractAddress>,
        spender: Either<ZswapCoinPublicKey, ContractAddress>
    ): Uint<128> {
        return allowances[owner][spender] ?? 0u128;
    }

    circuit transfer(
        from: Either<ZswapCoinPublicKey, ContractAddress>,
        to: Either<ZswapCoinPublicKey, ContractAddress>,
        amount: Uint<128>
    ): Void {
        let sender_balance = balances[from] ?? 0u128;
        assert(sender_balance >= amount, "Insufficient balance");
        
        balances[from] = sender_balance - amount;
        
        let recipient_balance = balances[to] ?? 0u128;
        balances[to] = recipient_balance + amount;
        
        return Void;
    }

    circuit approve(
        owner: Either<ZswapCoinPublicKey, ContractAddress>,
        spender: Either<ZswapCoinPublicKey, ContractAddress>,
        amount: Uint<128>
    ): Void {
        allowances[owner][spender] = amount;
        return Void;
    }

    circuit transfer_from(
        spender: Either<ZswapCoinPublicKey, ContractAddress>,
        from: Either<ZswapCoinPublicKey, ContractAddress>,
        to: Either<ZswapCoinPublicKey, ContractAddress>,
        amount: Uint<128>
    ): Void {
        let current_allowance = allowances[from][spender] ?? 0u128;
        assert(current_allowance >= amount, "Insufficient allowance");
        
        let sender_balance = balances[from] ?? 0u128;
        assert(sender_balance >= amount, "Insufficient balance");
        
        allowances[from][spender] = current_allowance - amount;
        balances[from] = sender_balance - amount;
        
        let recipient_balance = balances[to] ?? 0u128;
        balances[to] = recipient_balance + amount;
        
        return Void;
    }

    circuit mint(
        to: Either<ZswapCoinPublicKey, ContractAddress>,
        amount: Uint<128>
    ): Void {
        let recipient_balance = balances[to] ?? 0u128;
        balances[to] = recipient_balance + amount;
        total_supply = total_supply + amount;
        
        return Void;
    }
}